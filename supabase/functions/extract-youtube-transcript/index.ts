import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const deepseekApiKey = Deno.env.get('OPENAI_API_KEY'); // Using same env var for DeepSeek

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('Processing YouTube transcript extraction request');
    
    if (!deepseekApiKey) {
      throw new Error('DeepSeek API key not found');
    }
    
    const { youtube_url } = await req.json();
    
    if (!youtube_url) {
      throw new Error('YouTube URL is required');
    }

    // Extract video ID from YouTube URL
    const videoId = extractVideoId(youtube_url);
    if (!videoId) {
      throw new Error('Invalid YouTube URL format');
    }

    console.log('Extracting transcript for video ID:', videoId);

    // Use YouTube Data API to get video details and captions
    const transcriptData = await getYouTubeTranscript(videoId);
    
    if (!transcriptData || !transcriptData.transcript) {
      throw new Error('No transcript available for this video');
    }

    console.log('Successfully extracted transcript');
    
    return new Response(JSON.stringify({
      success: true,
      video_id: videoId,
      title: transcriptData.title,
      transcript: transcriptData.transcript,
      duration: transcriptData.duration
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    console.error('Error in extract-youtube-transcript function:', error);
    return new Response(JSON.stringify({ 
      success: false,
      error: error.message 
    }), {
      status: 200,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});

function extractVideoId(url: string): string | null {
  // More comprehensive video ID extraction patterns
  const patterns = [
    // Standard watch URL: https://www.youtube.com/watch?v=VIDEO_ID
    /(?:youtube\.com\/watch\?v=)([0-9A-Za-z_-]{11})/,
    // Short URL: https://youtu.be/VIDEO_ID
    /(?:youtu\.be\/)([0-9A-Za-z_-]{11})/,
    // Embed URL: https://www.youtube.com/embed/VIDEO_ID
    /(?:youtube\.com\/embed\/)([0-9A-Za-z_-]{11})/,
    // YouTube video URL with additional parameters
    /(?:youtube\.com\/.*[?&]v=)([0-9A-Za-z_-]{11})/,
    // Mobile URL: https://m.youtube.com/watch?v=VIDEO_ID
    /(?:m\.youtube\.com\/watch\?v=)([0-9A-Za-z_-]{11})/,
    // YouTube gaming URL
    /(?:gaming\.youtube\.com\/watch\?v=)([0-9A-Za-z_-]{11})/,
    // YouTube music URL
    /(?:music\.youtube\.com\/watch\?v=)([0-9A-Za-z_-]{11})/,
  ];
  
  // If it's already just a video ID (11 characters, alphanumeric + _ and -)
  if (url.match(/^[0-9A-Za-z_-]{11}$/)) {
    return url;
  }
  
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }
  
  return null;
}

async function getYouTubeTranscript(videoId: string) {
  try {
    console.log(`Attempting to fetch transcript for video ID: ${videoId}`);
    
    // First, try to get available caption tracks
    const captionListUrls = [
      `https://www.youtube.com/api/timedtext?type=list&v=${videoId}`,
      `https://video.google.com/timedtext?type=list&v=${videoId}`,
    ];
    
    let availableCaptions = [];
    
    // Get available caption tracks
    for (const listUrl of captionListUrls) {
      try {
        console.log(`Fetching caption list from: ${listUrl}`);
        const listResponse = await fetch(listUrl, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,*/*;q=0.5',
            'Accept-Language': 'en-US,en;q=0.5',
          }
        });
        
        if (listResponse.ok) {
          const listXml = await listResponse.text();
          console.log(`Caption list response length: ${listXml.length}`);
          
          if (listXml && listXml.includes('<track')) {
            const trackMatches = listXml.match(/<track[^>]*>/g) || [];
            
            for (const track of trackMatches) {
              const langMatch = track.match(/lang_code="([^"]+)"/);
              const nameMatch = track.match(/name="([^"]+)"/);
              const kindMatch = track.match(/kind="([^"]+)"/);
              
              if (langMatch) {
                const caption = {
                  lang: langMatch[1],
                  name: nameMatch ? nameMatch[1] : '',
                  kind: kindMatch ? kindMatch[1] : '',
                  isAutoGenerated: nameMatch ? nameMatch[1].toLowerCase().includes('auto') : false
                };
                availableCaptions.push(caption);
              }
            }
            
            console.log(`Found ${availableCaptions.length} available captions:`, availableCaptions);
            break;
          }
        }
      } catch (error) {
        console.log(`Caption list request failed: ${error.message}`);
        continue;
      }
    }
    
    // Prioritize captions: manual > auto-generated, English > other languages
    availableCaptions.sort((a, b) => {
      // Prioritize manual captions over auto-generated
      if (!a.isAutoGenerated && b.isAutoGenerated) return -1;
      if (a.isAutoGenerated && !b.isAutoGenerated) return 1;
      
      // Prioritize English languages
      const aIsEnglish = a.lang.startsWith('en');
      const bIsEnglish = b.lang.startsWith('en');
      if (aIsEnglish && !bIsEnglish) return -1;
      if (!aIsEnglish && bIsEnglish) return 1;
      
      return 0;
    });
    
    // Build transcript URLs based on available captions
    const transcriptUrls = [];
    
    // Try the best available captions first
    for (const caption of availableCaptions) {
      const formats = ['srv3', 'vtt', ''];
      const domains = ['https://www.youtube.com', 'https://video.google.com'];
      
      for (const domain of domains) {
        for (const fmt of formats) {
          const fmtParam = fmt ? `&fmt=${fmt}` : '';
          const kindParam = caption.kind ? `&kind=${caption.kind}` : '';
          transcriptUrls.push(`${domain}/api/timedtext?lang=${caption.lang}&v=${videoId}${fmtParam}${kindParam}`);
        }
      }
    }
    
    // Add fallback URLs for common languages
    const fallbackLanguages = ['en', 'en-US', 'en-GB', 'en-CA', 'en-AU'];
    const fallbackUrls = [];
    
    for (const lang of fallbackLanguages) {
      const formats = ['srv3', 'vtt', ''];
      const domains = ['https://www.youtube.com', 'https://video.google.com'];
      
      for (const domain of domains) {
        for (const fmt of formats) {
          const fmtParam = fmt ? `&fmt=${fmt}` : '';
          // Try both manual and auto-generated
          fallbackUrls.push(
            `${domain}/api/timedtext?lang=${lang}&v=${videoId}${fmtParam}`,
            `${domain}/api/timedtext?lang=${lang}&v=${videoId}${fmtParam}&kind=asr`
          );
        }
      }
    }
    
    // Try without language specification as last resort
    const genericUrls = [
      `https://www.youtube.com/api/timedtext?v=${videoId}&fmt=srv3`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&fmt=vtt`,
      `https://www.youtube.com/api/timedtext?v=${videoId}`,
      `https://video.google.com/timedtext?v=${videoId}&fmt=srv3`,
      `https://video.google.com/timedtext?v=${videoId}&fmt=vtt`,
      `https://video.google.com/timedtext?v=${videoId}`,
    ];
    
    // Combine all URLs, removing duplicates
    const allUrls = [...new Set([...transcriptUrls, ...fallbackUrls, ...genericUrls])];
    
    console.log(`Attempting to fetch transcript from ${allUrls.length} URLs...`);
    
    // Try each URL until we get a valid transcript
    for (let i = 0; i < allUrls.length; i++) {
      const url = allUrls[i];
      try {
        console.log(`[${i + 1}/${allUrls.length}] Trying: ${url}`);
        
        const response = await fetch(url, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,*/*;q=0.5',
            'Accept-Language': 'en-US,en;q=0.5',
            'Referer': 'https://www.youtube.com/',
          }
        });
        
        if (response.ok) {
          const content = await response.text();
          console.log(`Response received - Length: ${content.length}, Content type: ${response.headers.get('content-type') || 'unknown'}`);
          
          if (content && content.length > 10) {
            // Check if this looks like transcript content
            if (content.includes('<text') || content.includes('WEBVTT') || content.includes('<transcript') || content.includes('{"events"')) {
              try {
                const result = await parseTranscriptContent(content, videoId);
                if (result.transcript && result.transcript.length > 50) {
                  console.log(`✓ Successfully extracted transcript (${result.transcript.length} characters)`);
                  console.log(`Preview: ${result.transcript.substring(0, 150)}...`);
                  return result;
                }
              } catch (parseError) {
                console.log(`Parse failed for URL ${i + 1}: ${parseError.message}`);
                continue;
              }
            } else {
              console.log(`Content doesn't appear to be transcript data: ${content.substring(0, 100)}...`);
            }
          }
        } else {
          console.log(`HTTP ${response.status}: ${response.statusText}`);
        }
      } catch (error) {
        console.log(`Request failed: ${error.message}`);
        continue;
      }
    }
    
    // If we get here, no transcript was found
    throw new Error('No transcript available for this video. The video may not have captions enabled, may be age-restricted, private, or the captions may not be publicly accessible. Please try a different video with publicly available captions.');
    
  } catch (error) {
    console.error('Error fetching YouTube transcript:', error);
    throw error;
  }
}

async function parseTranscriptContent(content: string, videoId: string) {
  try {
    console.log('Parsing transcript content...');
    
    let transcript = '';
    
    // Handle WEBVTT format (like Python TextFormatter)
    if (content.includes('WEBVTT')) {
      console.log('Processing WEBVTT format');
      const lines = content.split('\n');
      const textLines = [];
      
      for (const line of lines) {
        const cleanLine = line.trim();
        // Skip WEBVTT headers, timestamps, cue settings, and empty lines
        if (cleanLine && 
            !cleanLine.startsWith('WEBVTT') && 
            !cleanLine.includes('-->') && 
            !cleanLine.match(/^\d+$/) &&
            !cleanLine.startsWith('NOTE ') &&
            !cleanLine.startsWith('STYLE ') &&
            !cleanLine.match(/^[\d:.,\s-]+$/)) { // Skip pure timestamp lines
          
          // Remove HTML/WebVTT tags and clean up
          const processedLine = cleanLine
            .replace(/<[^>]*>/g, '') // Remove HTML tags
            .replace(/\{[^}]*\}/g, '') // Remove WebVTT style tags
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'")
            .trim();
          
          if (processedLine && processedLine.length > 1) {
            textLines.push(processedLine);
          }
        }
      }
      
      // Join with spaces and clean up (like Python code does)
      transcript = textLines.join(' ')
        .replace(/\s+/g, ' ') // Multiple spaces to single space
        .trim();
    }
    
    // Handle XML timedtext format
    else if (content.includes('<text') || content.includes('<transcript')) {
      console.log('Processing XML timedtext format');
      
      // Extract text content from XML tags (similar to Python library approach)
      const textMatches = content.match(/<text[^>]*>([^<]*)<\/text>/g);
      
      if (textMatches && textMatches.length > 0) {
        const textParts = textMatches
          .map(match => {
            // Extract text content between tags
            const textContent = match
              .replace(/<text[^>]*>/, '')
              .replace(/<\/text>/, '')
              .replace(/&amp;/g, '&')
              .replace(/&lt;/g, '<')
              .replace(/&gt;/g, '>')
              .replace(/&quot;/g, '"')
              .replace(/&#39;/g, "'")
              .trim();
            return textContent;
          })
          .filter(text => text.length > 0);
        
        // Join all parts with spaces (like Python TextFormatter)
        transcript = textParts.join(' ')
          .replace(/\s+/g, ' ') // Clean up multiple spaces
          .trim();
      }
      
      // Fallback: try alternative XML parsing
      if (!transcript) {
        console.log('Trying alternative XML parsing method');
        const altMatches = content.match(/>([^<]+)</g);
        if (altMatches) {
          transcript = altMatches
            .map(match => match.slice(1, -1).trim())
            .filter(text => text.length > 0 && !text.match(/^\d+(\.\d+)?$/)) // Skip timestamps
            .join(' ')
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'")
            .replace(/\s+/g, ' ')
            .trim();
        }
      }
    }
    
    // Handle JSON format (some YouTube transcripts come as JSON)
    else if (content.includes('{"events"') || content.startsWith('{')) {
      console.log('Processing JSON format');
      try {
        const jsonData = JSON.parse(content);
        if (jsonData.events) {
          const textParts = jsonData.events
            .filter(event => event.segs)
            .flatMap(event => event.segs)
            .filter(seg => seg.utf8)
            .map(seg => seg.utf8.trim())
            .filter(text => text.length > 0);
          
          transcript = textParts.join(' ')
            .replace(/\s+/g, ' ')
            .trim();
        }
      } catch (jsonError) {
        console.log('JSON parsing failed:', jsonError.message);
      }
    }
    
    // Handle plain text format
    else {
      console.log('Processing as plain text');
      transcript = content
        .replace(/<[^>]*>/g, '') // Remove any HTML tags
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/\s+/g, ' ') // Multiple spaces to single space
        .trim();
    }
    
    // Validation (like Python code error handling)
    if (!transcript || transcript.length < 50) {
      throw new Error(`Transcript is too short or empty. Length: ${transcript.length}. Content preview: ${transcript.substring(0, 100)}`);
    }
    
    // Final cleanup (like Python's ' '.join(paragraph.split()))
    transcript = transcript
      .split(/\s+/) // Split on any whitespace
      .filter(word => word.length > 0) // Remove empty strings
      .join(' '); // Join with single spaces
    
    console.log(`✓ Successfully parsed transcript - ${transcript.length} characters`);
    console.log(`Transcript preview: ${transcript.substring(0, 200)}...`);
    
    // Get video metadata using oEmbed API (same as Python approach for getting title)
    let title = 'YouTube Video';
    
    try {
      const metadataResponse = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`);
      if (metadataResponse.ok) {
        const metadata = await metadataResponse.json();
        title = metadata.title || title;
        console.log(`Video title: ${title}`);
      }
    } catch (metadataError) {
      console.warn('Could not fetch video metadata:', metadataError.message);
    }
    
    return {
      title,
      transcript,
      duration: null
    };
    
  } catch (error) {
    console.error('Error parsing transcript content:', error);
    throw error;
  }
}